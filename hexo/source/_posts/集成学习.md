---
title: 集成学习1——理论
top: false
cover: false
toc: true
mathjax: true
date: 2019-09-19 20:37:43
password:
summary:
copyright: true
tags: 
  - ML
  - 集成学习
  - 随机森林
  - 提升树
categories: Machine learning
---

### 集成学习
所谓集成学习就是综合多人的意见来进行决策会比一个人的决策来的更好。集成学习的关键是：如何选择、生成弱分类器和如何对它们进行提升。三种思路：
- 将不同类型的弱分类进行提升
- 将相同类型但是参数不同的弱分类器进行提升
    - 分类器之间依赖性不强，能够同时进行
    - 并行方法，`Bagging`，扩展应用：随机森林`Random Forest`
- 将相同类型但是训练数据不同的弱分类器进行提升
    - 分类器之间依赖性很强，只能序列生成
    - 串行方法，`Boosting`，扩展应用：提升树`AdaBoost`

常见的集成学习方法有两种：`Bagging`和`AdaBoost`。



[集成学习总结 & Stacking方法详解](https://blog.csdn.net/willduan1/article/details/73618677)

<!-- MORE-->




### Bagging和随机森林
#### `Bootstrap`理论
随机森林源自于`Bootstrap`理论（自举）：通过模拟的方法来逼近样本的概率分布。假设有包含$N$个样本的数据集$X=\{x_1,x_2,....,x_N\}，$Bootstrap的做法：
- 从样本$X$中随机抽出一个样本（假设抽出$x_1,x_2,...,x_N$的概率相同）
- 将样本的拷贝放入数据集$X_j$
- 将该样本放回原数据集$X$中
- 重复上述步骤$N$次，从而使得$X_j$中含有$N$个样本，得到$\{X_1,X_2,...,X_M\}$，其中$j=1,2,...,M$每个数据集中含有$N$个样本


**Bootstrap是有放回的随机抽样过程**

一个样本在N次采样中不始终不被采到的概率$(1-\frac1N)^N$,且有结
$$
\lim \limits_{N\to \infty}(1-\frac 1 N)^N \to \frac 1 e \approx0.368
$$
果表明：原样本中约有$\frac 1 3$的数据抽不到。

经验分布函数的数学表达式
$$
F_N(x)=\frac 1 N\sum_{i=1}^{N}I_{-\infty,x}(x_i)
$$

- 经验分布函数用到了**频率估计概率**的思想
- 用经验分布来模拟真实分布

#### Bagging
`Bagging`的全称是`Bootstrap Aggregating`，其思想是：
- 用Bootstrap来训练M个训练数据集

- 用M个数据集训练出M个弱分类器

- 最终模型就是M个弱分类器的`简单组合`
    - 分类：简单的投票表决
    - 回归：简单的取平均
    
- 假设样本，空间到类别空间的真实映射为$f$，M个弱分类器所对应的的映射为$g_1,g_2,...,g_M$，简单组合下的模型对应映射为
    $$
    g(x)=sign(\sum_{j=1}^Ng_j(x))
    $$
    $sign(x)$是符号函数，每个弱分类器的错误率为
    $$
    p(g_i(x)\neq f(x))=\epsilon
    $$
    可以证明：最终模型的错误率随着弱分类器个数M的增加，呈指数级下降最终趋于0


![](https://s2.ax1x.com/2019/09/23/uFpOnf.png)

#### 随机森林
随机森林思想：

- 用`Bootstrap`来训练`M`个训练数据集
- 用M个数据集训练出`M`棵不进行后剪枝决策树，且在每次决策树生成的过程中，对`Node`进行划分，
- 从可选特征(假设`d`个)中随机选出k个特征，依据信息增益的定义，选择出信息增益最大的特征作为划分标准
- 最终模型即为M个弱分类器的简单组合，`k`一般是$k=log_2d$
- 两个随机性：
    - 样本的随机采样
    - 特征的随机采样
- 袋装法集成时，基分类器是相互独立的，是不同的



#### 重要参数和属性

- 决策树中的常用参数
- `random_state`
- 属性：`estimators`









-----



### Adaboost

提升方法使用常用的统计学习方法。提升方法的基本思想：对于一个复杂的任务，将多个专家的判断进行适当地综合得到的判断，要比其中任何一个的结果都要好。将弱学习算法生成的弱模型，提升成和强学习算法所生成的强模型性能差不多的模型的方法。
- 强可学习：在概率近似正确的学习框架中，若存在一个多项式的学习算法能够学习它，并且准确率很高，称为`强可学习`
- 弱可学习：如果学习的概率仅比随机预测的效果好，称为`弱可学习`
- 一个概念强可学习的充要条件是这个概念是弱可学习的

#### 提升方法Boosting
从给定的数据集中，学习得到一系列弱分类器，组合弱分类，构成强分类器。通常进行的处理是
- 加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用：让弱模型做错的样本获得更多的关注
- 减小分类误差较大的弱分类器的权值，使其在表决中起较小的作用：让弱模型做对的样本获得更少的关注

![](https://s2.ax1x.com/2019/09/23/uF9EHU.png)


#### AdaBoost算法
给定样本$T={(x_1,y_1),...,(x_N,y_N)},y_i\in {+1, -1}$，$\chi$是实例空间，$Y$是标记组合。算法过程
- 输入：训练数据集合T，包含实例空间和标记组合；输出：最终分类器`G(x)`

- （1）初始化数据的权值分布：
    $$
    D_1=(w_{11},...,w_{1i},...,w_{1N})
    $$
    其中$w_{1i}=\frac{1}{N}，i=1,2,...,N$

- （2）对于m=1,2,...,M
    - 使用具有权值分布$D_m$的训练数据集来学习，得到基本分类器
      $$
      G_m(x):X \to \{-1, +1\}
      $$
      
    - 计算$G_m(x)$在训练数据集上的分类误差率：
      $$
      e_m=\sum^N_{i=1}P(G_m(x_i)\neq y_i)=\sum w_{mi}I(G_m(x_i)\neq y_i)
      $$
      
    - 计算$G_m(x)$的系数
      $$
      \alpha_m = \frac{1}{2}log \frac{1-e_m}{e_m}
      $$
      
    
- （3）更新训练数据的权值分布
  $$
  D_{m+1}=(w_{m+1,1},...,w_{m+1,i},...,w_{m+1,N})
  $$

  $$
  w_{m+1,i}=\frac {w_{mi}}{Z_m}exp(-\alpha_m y_i G_m(x_i)), i=1,2,...,N
  $$

  

- （4）$Z_m$是规范化因子
    $$
    Z_m=\sum^N_{i=1}w_{mi}exp(-\alpha_m y_i G_m(x_i))
    $$
    
- （5）构建基本分类器的线性组合
    $$
    f(x)=\sum^M_{m=1}\alpha_m G_m(x_i)
    $$
    
- （6）得到最终的分类器
  $$
  G(x)=sign(f(x))=sign(\sum^M_{m=1}\alpha_mG_m(x))
  $$
  

#### 算法说明
- （1）中假设数据具有均匀的权值分布，每个训练样本在基本分类器上的作用是相同的
- （2）反复学习基本分类器，每轮进行$m=1,...,M$次操作
    - 使用当前分布的$D_m$加权的训练数据集，学习基本分类器$G_m(x)$
    
    - 计算基本分类器在加权训练数据集上的分类误差率
      $$
      e_m=\sum^N_{m=1}P(G_m(x_i)\neq y_i)
      $$
      
      $$
      e_m=\sum_{G_m(x_i)\neq y_i}w_{mi}
      $$
      
    
- 说明几点
    - $w_{mi}$表示的是第m轮中第i个实例的权值，$\sum^N_{i=1}w_{mi}=1$
    - 分类误差率是被$G_m(x)$误分类样本的权值之和
- 计算基本误分类器的系数$\alpha_m$。$\alpha$表示$G_m(x)$在最终分类器中的重要性